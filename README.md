# ImgHaul
#### Video Demo:  <URL HERE>
#### Description:
ImgHaul is a desktop application for transferring images and other files from one storage location to another, primarily from cameras to PCs. It has many built in features that I find useful when transferring images from my camera to my PC that other photo editing apps like Photoshop, Lightroom, and GIMP don't offer (or aren't easily accessible). Using ImgHaul, I can now select all the images and files I want to transfer, have them automatically placed in a new folder, rename all files with a new naming scheme, and even copy them as smaller JPEGs. My favorite feature, however, is the focal length graph. After long photography trips, I often wondered what focal lengths (zooms) I used most often. This information can be useful for knowing which lenses I should invest in in the future.ImgHaul generates a bar plot using MatPlotLib that shows how many images I took with each focal length, making it very clear which lenses I would find the most useful and which ones I likely wouldn't use much. The only other tool I found that has this feature is ExifTool, which is very old, a hassle to install, and clunky to use. ImgHaul is written in Python and the GUI is built using the tkinter library. Image opening and processing is handled by Python's Pillow library PIL.

The first step for creating this project was designing the GUI. I used Tkinter, which is a simple, but powerful python library for building GUIs. I had only ever made GUIs in Java using JFrame (which works very differently from Tkinter), so this was very new to me. I found that building GUIs with Tkinter feels a lot more like arranging elements in HTML and stylizing them with CSS than the previous work I did in Java. Elements can be arranged in Frames (like a HTML <div>) and then placed on a grid within each frame. These frames with frames inside of them can also be placed on a grid. Although quite confusing at first, with a couple days of practice, this system made it easy to get the GUI looking the way I wanted it to. It evolved quite a bit as I thought of new features to add, but the basic idea was this: textbox listing all of the selected files on the side, transfer/copy options on the bottom, focal length chart on top. Initially, I wanted to allow users to drag and drop their files into ImgHaul. Tkinter doesn't natively support this functionality, but I found python libraries and some github forks like tkinterdnd2 that would allow me to implement this. However, after spending nearly 2 whole days trying to install these libraries and get them to work with my python installation, I was forced to give up. I tried pip installing them, as their websites claimed would work. I tried installing directly from github. I tried setting up pyenv to run older versions of python. I tried deleting my python and reinstalling the older versions. I installed dozens of other things the websites said were dependencies. In the end, none of these worked and I was happy enough with the browse button that I decided to move on to other parts of the project. Maybe in the future I'll come back and figure out how to get these libraries to work or implement my own from scratch.

After setting up the GUI, I moved on to writing the commands for the buttons. Each tkinter button can be tied to a python function, so the bulk of the project's backend would be run inside of these functions. I'll run through each function in order of appearance, explaining what they do and any challenges I ran into while writing them:

get_files():
Upon clicking the browse button below the file path listbox, this function opens up the native file explorer and allows the user to select files for transferring. It then adds each file's full path to the listbox so the user can see them and also to the global paths array. It does not accept duplicate file paths.

remove_files():
Remove files initializes an array of paths, populates it with all the items currently selected in the listbox (highlighted/clicked by the user), then removes them from both the listbox and the global paths array. The two loops were necessary for ordering purposes. listbox.delete(item) is index based, so I had to remove the last files first to not mess up the indexing with each delete. By inserting each new selection to the front, I reordered the files backwards, avoiding this issue. Once all selected files are removed, remove_files() calls genPyplot(), which updates the focal length pyplot to represent the new selection of files.

get_destination(): 
Simply opens up the native file explorer and asks for a destination directory for the files, setting the dest_path StringVar to this new path. This updates the destination label, which is displayed to the user.

folderLockToggle(), renameLockToggle():
These two functions are nearly identical. In hindsight, they could have been the same function with the necessary parameters passed in, but they are not too long, so it's not that bad. They handle disabling and enabling the entry boxes for renaming files and naming the new folder with respect to their checkboxes. 

Error():
I was inspired by the CS50 finance webpage assignment to make my own error message popup in tkinter that kills the program if you call it, preventing you from messing up file naming or corrupting data. I achieved this by creating a tkinter toplevel object (like a popup), preventing the user from interacting with the main window, displaying an error message, and waiting for the user to close the popup to close the app. I did all of this, only to find out that tkinter has built in messageboxes that have the same functionality. I left this function in commented out, but all uses were replaced by tkinter messageboxes.

def success():
This works a lot like the Error() popups, so they could also be replaced by tkinter messageboxes. However making my own popup from scratch makes it easier to customize the success messages in the future if I decide to add more functionality. For example, if I want to add some basic image editing I can display the final images in this popup.

genPyplot():
This is a very long function that does the bulk of the processing in ImgHaul. It generates a matplotlib.pyplot bar plot based on the focal length exif data of the images in the files listbox. I knew that that each image taken by a camera or a phone has some baked-in information called EXIF data. I didn't realize how much of it each picture had. The raw images coming out of my camera dozens of information tags (like keys in a dictionary) for mostly obscure information that wasn't important to me at all. I only really cared about one tag -- focal length. I found a python library for reading and processing exif data called exifread. I was very pleased when a simple pip install worked on the first try (as opposed to my tkinter drag and drop nightmare). In the first build of this function, it initialized a dictionary mm for storing focal lengths as keys and the number of occurrences as values. It then opened up each file in the global paths array (with 'rb' read binary option required by exifread). Next, exifread processed the file and stored the information in tags, an incredibly large dictionary. After some finicky datatype conversion, it set the focal length to 1 if it hadn't yet appeared in the mm dict and +=1 the value if it had. Finally, it sets up the actual barplot with the data from the dict and places it in the appropriate location within the tkinter GUI. I ran into a lot of errors in this function's first build. First, it worked just fine with small file counts, but once I tested it with the files from a week-long photography trip (2300+ files, ~63GB), it took about 5-10 minutes to process them. I also realized that my camera was recording fractional focal lengths (like 63/2 mm). These are not very useful for me, but annoyingly, they are stored as strings so I had to string process the "/" out. I didn't care about storing the fractional focal lengths, so I just rounded them off to the nearest integer and stored them like that. Also, the program crashed when it ran into .mov files or any other non-image file that doesn't have EXIF data. I solved this by using a "with open(file, 'rb') as f" instead of just opening the files directly. I'm not sure how or why exactly this worked, but it seems the "with" helps with exception handling. Now, it just prints "invalid file type" to console instead of crashing the program. This issue will come back in the move() function. I also tried many different possible solutions for optimizing the EXIF data processing. Many of these were incredibly complicated and none of them really worked as well as I hoped. The final solution was embarrasingly simple. Adding a details=false argument to exifread.process_file() changed the processing time of the same 2300 file folder from nearly 10 minutes to about 15 seconds. It's not the fastest in the world, but it's a huge improvement and it's fast enough for my personal use. 

move():
This function is where all of the moving, copying, renaming, and image processing happens. It could definitely have been split up into a number of other functions to make it more readable, but it is very thoroughly commented, so I think it's legible enough. Processing splits into two cases: copying as jpeg or just transfering files, as controlled by the "Copy as JPEG" checkbox. Both start by checking if I am going to rename the files with my own prefix. If not, then I can just generate the file's new path and use shutil.move() to move it there. If I am renaming the files, I have to input validate the prefix so it's not empty and doesn't contain any illegal characters. Most of the characters there are not actually illegal, but different operating systems have different requirements, so I chose the safe route of banning all obscure symbols. Then, both copy as JPEG and transfer generate the new name and use shutil.move() to move it to the new destination. Shutil.move() seems to be safe for the most part. If it fails to copy the file to the destination, it will not remove the original, keeping the data safe. Copying as JPEG requires extra processing. I think this is what actually caused the program to crash, not genPyplot(). Image.open()-ing unsupported files and then trying to convert image modes and processing them as JPEGS would crash the program. I hoped the with open solution from before would work, but it did not. I ended up putting the processing in a try except, where if opening the file works, it will convert to the proper image mode, set the quality to whatever the user specified using the slider, and reformat the image to a JPEG. If it can't open the file, it will print the message "Invalid file type" to the console, but will not crash and continues processing the rest of the images. I'd say that move() and genPyplot() were by far the most difficult and finicky parts of this project, followed closely by learning tkinter on my own from online sources and their documentation.

go():
This function contains some input validation, making sure files are selected, a destination is set, and that the name of the new folder to be generated doesn't contain illegal characters (if the option to make a new folder is selected). It will also make the new folder and set it as the dest_path if the user chooses to do so. Then, after all of this, it calls move() to start transferring the files.

Below all of these functions is the GUI setup.


OVERVIEW:
I'm quite happy with the way this project turned out. I will use this app every time I transfer images from my camera to my PC just for the renaming and focal length graph functions. I learned a lot of new libraries and workflows in creating this project. I got extra practice with python, learned how to make GUIs with tkinter, how to make plots with matplotlib, how to process images with PIL, how to move files with shutil, and I learned what EXIF data actually is and how to read it with python. 

The most valuable things, however, were learning git/github and all of the practice with installing libraries and dependencies in my command prompt and mac's unix terminal. I wanted to work on my PC when I was at home, but also work on the same project on my mac while on campus. So I finally put my github account to use and started filling in the activity calendar with some green boxes :) 

On the other hand, the installations almost made my lose my mind. Tkinderdnd legitimately took me two days and probably about 6-10 hours of troubleshooting before I gave up on it. I probably made a complete mess on my pc with all of those installations. I did learn, however, how installing other people's add-ons to existing libraries SHOULD work.

The most frustrating part of this project was caused by this add-on called rawpy. The only reason I made the "Copy as JPEG" option was to get smaller copies of the massive raw .NEF files coming out of my camera. If I just want to post on Instagram or share images with friends and family, I don't need the full files (which can be upwards of 30 MB each), a small JPEG will do. However, after trying to install 6 different libraries, troubleshooting each of them, I simply couldn't get it to work. Turning other file types into lower quality JPEGs works just fine, but trying to turn raw .NEF files into JPEGs only alters the garbage resolution thumbnail, turning a ~3000x4000px image into a ~200x300. This was unbelievably frustrating. It seems that rawpy is the most used extension of the array of libraries I tried to use to properly process the images. Rawpy is a wrapper for LibRaw, a C++ library for processing raw images. LibRaw seems to be much more legitimate than rawpy, with active support (who were very helpful) and frequent updates. Installing LibRaw was tricky. I had to use a bunch of commands that were very foreign to me to compile it and set it up. I had to install macports, autoconfig, and tons of other tools just to set it up. Then I had to make a config file for it, run it, then make it in terminal, and sudo make install. All of these were very foreign to me, but after setting it all up properly, rawpy refused to work with the newest version of LibRaw. I was ECSTATIC to find out there is no way to easily uninstall all of the files I just scattered across my mac. I redid the whole process with the versions of LibRaw that rawpy users mentioned on StackOverflow from 2018 (the most recent mention of it I could find), but rawpy still refused to work. If I can find a way to get raw image processing to work with ImgHaul, I will come back and fix it immediately, because I was really excited to have that copying as JPEG functionality. It seems that Python is just the wrong language to try to do this in. I am learning C++ in school, so maybe I will remake ImgHaul in C++. However, I imagine the GUI will be much, much more complicated, if it's even possible. It will definitely run faster, though, since I would be able to manually handle memory allocation. I'll save that for a future project, once I get better at C++. 

As of now, I'm pleased with this project. It combines all of the functionality I need for transferring and handling my photography files (except for the raw to JPEG disaster) in one place. I'll be making heavy use of it. Tkinter apps can be turned into single .exe files for sharing. I hoped to do this and be able to provide it for you guys, for my friends, and for my own personal use. However, Windows defender thinks it is a trojan virus, probably because it moves files around your PC and I have no clue where to even begin trying to solve that, so I think it's wise to just keep it for my own personal use. 